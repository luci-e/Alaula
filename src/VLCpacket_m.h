//
// Generated file, do not edit! Created by nedtool 4.6 from src/VLCpacket.msg.
//

#ifndef _VLCPACKET_M_H_
#define _VLCPACKET_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



/**
 * Enum generated from <tt>src/VLCpacket.msg:16</tt> by nedtool.
 * <pre>
 * enum VLCmsgType
 * {
 * 
 *     VLC_MOVE_MSG = 0;
 * 
 *     VLC_SIG_BEGIN_MSG = 1;
 *     VLC_SIG_END_MSG = 2;
 * 
 *     VLC_CTRL_MSG = 3;
 *     VLC_DATA_MSG = 4;
 * }
 * </pre>
 */
enum VLCmsgType {
    VLC_MOVE_MSG = 0,
    VLC_SIG_BEGIN_MSG = 1,
    VLC_SIG_END_MSG = 2,
    VLC_CTRL_MSG = 3,
    VLC_DATA_MSG = 4
};

/**
 * Enum generated from <tt>src/VLCpacket.msg:26</tt> by nedtool.
 * <pre>
 * enum VLCctrlCode
 * {
 * 
 *     // Codes for the status of the transmission
 *     TRANSMISSION_DONE = 0;
 *     TRANSMISSION_ABORTED = 1;
 * 
 *     // Codes for the status of the device		
 *     DEVICE_BUSY = 2;
 * 
 *     // Codes for controlling the transmission
 *     ABORT_TRANSMISSION = 3;
 * }
 * </pre>
 */
enum VLCctrlCode {
    TRANSMISSION_DONE = 0,
    TRANSMISSION_ABORTED = 1,
    DEVICE_BUSY = 2,
    ABORT_TRANSMISSION = 3
};

/**
 * Enum generated from <tt>src/VLCpacket.msg:38</tt> by nedtool.
 * <pre>
 * enum VLCmodulationType
 * {
 * 
 *     PAM = 0;
 *     VPPM = 1;
 * }
 * </pre>
 */
enum VLCmodulationType {
    PAM = 0,
    VPPM = 1
};

/**
 * Class generated from <tt>src/VLCpacket.msg:43</tt> by nedtool.
 * <pre>
 * packet VLCpacket
 * {
 *     int messageType @enum(VLCmsgType);
 * }
 * </pre>
 */
class VLCpacket : public ::cPacket
{
  protected:
    int messageType_var;

  private:
    void copy(const VLCpacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VLCpacket&);

  public:
    VLCpacket(const char *name=NULL, int kind=0);
    VLCpacket(const VLCpacket& other);
    virtual ~VLCpacket();
    VLCpacket& operator=(const VLCpacket& other);
    virtual VLCpacket *dup() const {return new VLCpacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMessageType() const;
    virtual void setMessageType(int messageType);
};

inline void doPacking(cCommBuffer *b, VLCpacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VLCpacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/VLCpacket.msg:47</tt> by nedtool.
 * <pre>
 * packet VLCmoveMsg extends VLCpacket
 * {
 *     int nodeId;
 * }
 * </pre>
 */
class VLCmoveMsg : public ::VLCpacket
{
  protected:
    int nodeId_var;

  private:
    void copy(const VLCmoveMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VLCmoveMsg&);

  public:
    VLCmoveMsg(const char *name=NULL, int kind=0);
    VLCmoveMsg(const VLCmoveMsg& other);
    virtual ~VLCmoveMsg();
    VLCmoveMsg& operator=(const VLCmoveMsg& other);
    virtual VLCmoveMsg *dup() const {return new VLCmoveMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNodeId() const;
    virtual void setNodeId(int nodeId);
};

inline void doPacking(cCommBuffer *b, VLCmoveMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VLCmoveMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/VLCpacket.msg:51</tt> by nedtool.
 * <pre>
 * packet VLCchannelSignalBegin extends VLCpacket
 * {
 *     int nodeId;
 * }
 * </pre>
 */
class VLCchannelSignalBegin : public ::VLCpacket
{
  protected:
    int nodeId_var;

  private:
    void copy(const VLCchannelSignalBegin& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VLCchannelSignalBegin&);

  public:
    VLCchannelSignalBegin(const char *name=NULL, int kind=0);
    VLCchannelSignalBegin(const VLCchannelSignalBegin& other);
    virtual ~VLCchannelSignalBegin();
    VLCchannelSignalBegin& operator=(const VLCchannelSignalBegin& other);
    virtual VLCchannelSignalBegin *dup() const {return new VLCchannelSignalBegin(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNodeId() const;
    virtual void setNodeId(int nodeId);
};

inline void doPacking(cCommBuffer *b, VLCchannelSignalBegin& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VLCchannelSignalBegin& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/VLCpacket.msg:55</tt> by nedtool.
 * <pre>
 * packet VLCchannelSignalEnd extends VLCpacket
 * {
 *     int nodeId;
 * }
 * </pre>
 */
class VLCchannelSignalEnd : public ::VLCpacket
{
  protected:
    int nodeId_var;

  private:
    void copy(const VLCchannelSignalEnd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VLCchannelSignalEnd&);

  public:
    VLCchannelSignalEnd(const char *name=NULL, int kind=0);
    VLCchannelSignalEnd(const VLCchannelSignalEnd& other);
    virtual ~VLCchannelSignalEnd();
    VLCchannelSignalEnd& operator=(const VLCchannelSignalEnd& other);
    virtual VLCchannelSignalEnd *dup() const {return new VLCchannelSignalEnd(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNodeId() const;
    virtual void setNodeId(int nodeId);
};

inline void doPacking(cCommBuffer *b, VLCchannelSignalEnd& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VLCchannelSignalEnd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/VLCpacket.msg:59</tt> by nedtool.
 * <pre>
 * packet VLCctrlMsg extends VLCpacket
 * {
 *     int ctrlCode @enum(VLCctrlCode);
 * }
 * </pre>
 */
class VLCctrlMsg : public ::VLCpacket
{
  protected:
    int ctrlCode_var;

  private:
    void copy(const VLCctrlMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VLCctrlMsg&);

  public:
    VLCctrlMsg(const char *name=NULL, int kind=0);
    VLCctrlMsg(const VLCctrlMsg& other);
    virtual ~VLCctrlMsg();
    VLCctrlMsg& operator=(const VLCctrlMsg& other);
    virtual VLCctrlMsg *dup() const {return new VLCctrlMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getCtrlCode() const;
    virtual void setCtrlCode(int ctrlCode);
};

inline void doPacking(cCommBuffer *b, VLCctrlMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VLCctrlMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/VLCpacket.msg:63</tt> by nedtool.
 * <pre>
 * packet dataPacket extends VLCpacket
 * {
 *     int modulationType @enum(VLCmodulationType);
 *     double transmissionPower;
 *     int modulationOrder;
 *     double dutyCycle;
 *     string content;
 *     double transmissionStartTime;
 * }
 * </pre>
 */
class dataPacket : public ::VLCpacket
{
  protected:
    int modulationType_var;
    double transmissionPower_var;
    int modulationOrder_var;
    double dutyCycle_var;
    opp_string content_var;
    double transmissionStartTime_var;

  private:
    void copy(const dataPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const dataPacket&);

  public:
    dataPacket(const char *name=NULL, int kind=0);
    dataPacket(const dataPacket& other);
    virtual ~dataPacket();
    dataPacket& operator=(const dataPacket& other);
    virtual dataPacket *dup() const {return new dataPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getModulationType() const;
    virtual void setModulationType(int modulationType);
    virtual double getTransmissionPower() const;
    virtual void setTransmissionPower(double transmissionPower);
    virtual int getModulationOrder() const;
    virtual void setModulationOrder(int modulationOrder);
    virtual double getDutyCycle() const;
    virtual void setDutyCycle(double dutyCycle);
    virtual const char * getContent() const;
    virtual void setContent(const char * content);
    virtual double getTransmissionStartTime() const;
    virtual void setTransmissionStartTime(double transmissionStartTime);
};

inline void doPacking(cCommBuffer *b, dataPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, dataPacket& obj) {obj.parsimUnpack(b);}


#endif // ifndef _VLCPACKET_M_H_


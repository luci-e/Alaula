//
// Generated file, do not edit! Created by nedtool 4.6 from src/VLCpacket.msg.
//

#ifndef _VLCPACKET_M_H_
#define _VLCPACKET_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



/**
 * Enum generated from <tt>src/VLCpacket.msg:16</tt> by nedtool.
 * <pre>
 * enum VLCmsgType
 * {
 * 
 *     VLC_CTRL_MSG = 0;
 *     VLC_DATA_MSG = 1;
 *     VLC_MAC_MSG = 2;
 * }
 * </pre>
 */
enum VLCmsgType {
    VLC_CTRL_MSG = 0,
    VLC_DATA_MSG = 1,
    VLC_MAC_MSG = 2
};

/**
 * Enum generated from <tt>src/VLCpacket.msg:22</tt> by nedtool.
 * <pre>
 * enum VLCctrlCode
 * {
 * 
 *     // Codes for the status of the transmission
 *     TRANSMISSION_BEGIN = 0;
 *     TRANSMISSION_END = 1;
 *     TRANSMISSION_ABORT = 2;
 * 
 * 
 *     // Codes for the status of the device		
 *     DEVICE_BUSY = 3;
 *     DEVICE_MOVED = 4;
 *     NOISE_DEVICE_CHANGED = 5;
 * 
 *     // Codes for controlling the transmission
 *     ABORT_TRANSMISSION = 6;
 * 
 *     // Codes for controlling the transmission
 *     VPPM_CYCLE_DOWN = 7;
 * 
 *     // Codes for the app
 *     NEW_PACKET = 8;
 * 
 *     //Codes for the receiver
 *     CHECK_BEACON = 9;
 * 
 * }
 * </pre>
 */
enum VLCctrlCode {
    TRANSMISSION_BEGIN = 0,
    TRANSMISSION_END = 1,
    TRANSMISSION_ABORT = 2,
    DEVICE_BUSY = 3,
    DEVICE_MOVED = 4,
    NOISE_DEVICE_CHANGED = 5,
    ABORT_TRANSMISSION = 6,
    VPPM_CYCLE_DOWN = 7,
    NEW_PACKET = 8,
    CHECK_BEACON = 9
};

/**
 * Enum generated from <tt>src/VLCpacket.msg:48</tt> by nedtool.
 * <pre>
 * enum VLCMACCode
 * {
 * 
 *     BEACON_MSG = 0;
 *     SUBSCRIBE_MSG = 1;
 *     UNSUBSCRIBE_MSG = 2;
 * }
 * </pre>
 */
enum VLCMACCode {
    BEACON_MSG = 0,
    SUBSCRIBE_MSG = 1,
    UNSUBSCRIBE_MSG = 2
};

/**
 * Enum generated from <tt>src/VLCpacket.msg:54</tt> by nedtool.
 * <pre>
 * enum VLCmodulationType
 * {
 * 
 *     PAM = 0;
 *     VPPM = 1;
 * }
 * </pre>
 */
enum VLCmodulationType {
    PAM = 0,
    VPPM = 1
};

/**
 * Class generated from <tt>src/VLCpacket.msg:59</tt> by nedtool.
 * <pre>
 * packet VLCpacket
 * {
 *     int messageType @enum(VLCmsgType);
 * }
 * </pre>
 */
class VLCpacket : public ::cPacket
{
  protected:
    int messageType_var;

  private:
    void copy(const VLCpacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VLCpacket&);

  public:
    VLCpacket(const char *name=NULL, int kind=0);
    VLCpacket(const VLCpacket& other);
    virtual ~VLCpacket();
    VLCpacket& operator=(const VLCpacket& other);
    virtual VLCpacket *dup() const {return new VLCpacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMessageType() const;
    virtual void setMessageType(int messageType);
};

inline void doPacking(cCommBuffer *b, VLCpacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VLCpacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/VLCpacket.msg:63</tt> by nedtool.
 * <pre>
 * packet VLCctrlMsg extends VLCpacket
 * {
 *     int nodeId;
 *     int nodeAddress;
 *     int ctrlCode @enum(VLCctrlCode);
 * }
 * </pre>
 */
class VLCctrlMsg : public ::VLCpacket
{
  protected:
    int nodeId_var;
    int nodeAddress_var;
    int ctrlCode_var;

  private:
    void copy(const VLCctrlMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VLCctrlMsg&);

  public:
    VLCctrlMsg(const char *name=NULL, int kind=0);
    VLCctrlMsg(const VLCctrlMsg& other);
    virtual ~VLCctrlMsg();
    VLCctrlMsg& operator=(const VLCctrlMsg& other);
    virtual VLCctrlMsg *dup() const {return new VLCctrlMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNodeId() const;
    virtual void setNodeId(int nodeId);
    virtual int getNodeAddress() const;
    virtual void setNodeAddress(int nodeAddress);
    virtual int getCtrlCode() const;
    virtual void setCtrlCode(int ctrlCode);
};

inline void doPacking(cCommBuffer *b, VLCctrlMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VLCctrlMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/VLCpacket.msg:69</tt> by nedtool.
 * <pre>
 * packet VLCnoiseControlMsg extends VLCctrlMsg
 * {
 *     double noisePower;
 * }
 * </pre>
 */
class VLCnoiseControlMsg : public ::VLCctrlMsg
{
  protected:
    double noisePower_var;

  private:
    void copy(const VLCnoiseControlMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VLCnoiseControlMsg&);

  public:
    VLCnoiseControlMsg(const char *name=NULL, int kind=0);
    VLCnoiseControlMsg(const VLCnoiseControlMsg& other);
    virtual ~VLCnoiseControlMsg();
    VLCnoiseControlMsg& operator=(const VLCnoiseControlMsg& other);
    virtual VLCnoiseControlMsg *dup() const {return new VLCnoiseControlMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual double getNoisePower() const;
    virtual void setNoisePower(double noisePower);
};

inline void doPacking(cCommBuffer *b, VLCnoiseControlMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VLCnoiseControlMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/VLCpacket.msg:73</tt> by nedtool.
 * <pre>
 * packet VLCMACMsg extends VLCpacket
 * {
 *     int MACCode @enum(VLCMACCode);
 *     int transmitterNodeId;
 *     int transmitterNodeAddress;
 *     int receiverNodeIde;
 *     int receiverNodeAddress;
 * }
 * </pre>
 */
class VLCMACMsg : public ::VLCpacket
{
  protected:
    int MACCode_var;
    int transmitterNodeId_var;
    int transmitterNodeAddress_var;
    int receiverNodeIde_var;
    int receiverNodeAddress_var;

  private:
    void copy(const VLCMACMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VLCMACMsg&);

  public:
    VLCMACMsg(const char *name=NULL, int kind=0);
    VLCMACMsg(const VLCMACMsg& other);
    virtual ~VLCMACMsg();
    VLCMACMsg& operator=(const VLCMACMsg& other);
    virtual VLCMACMsg *dup() const {return new VLCMACMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMACCode() const;
    virtual void setMACCode(int MACCode);
    virtual int getTransmitterNodeId() const;
    virtual void setTransmitterNodeId(int transmitterNodeId);
    virtual int getTransmitterNodeAddress() const;
    virtual void setTransmitterNodeAddress(int transmitterNodeAddress);
    virtual int getReceiverNodeIde() const;
    virtual void setReceiverNodeIde(int receiverNodeIde);
    virtual int getReceiverNodeAddress() const;
    virtual void setReceiverNodeAddress(int receiverNodeAddress);
};

inline void doPacking(cCommBuffer *b, VLCMACMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VLCMACMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/VLCpacket.msg:81</tt> by nedtool.
 * <pre>
 * packet VLCBeaconMsg extends VLCMACMsg
 * {
 *     int modulationType @enum(VLCmodulationType);
 *     double transmissionPower;
 *     int modulationOrder;
 *     double dutyCycle;
 * }
 * </pre>
 */
class VLCBeaconMsg : public ::VLCMACMsg
{
  protected:
    int modulationType_var;
    double transmissionPower_var;
    int modulationOrder_var;
    double dutyCycle_var;

  private:
    void copy(const VLCBeaconMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VLCBeaconMsg&);

  public:
    VLCBeaconMsg(const char *name=NULL, int kind=0);
    VLCBeaconMsg(const VLCBeaconMsg& other);
    virtual ~VLCBeaconMsg();
    VLCBeaconMsg& operator=(const VLCBeaconMsg& other);
    virtual VLCBeaconMsg *dup() const {return new VLCBeaconMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getModulationType() const;
    virtual void setModulationType(int modulationType);
    virtual double getTransmissionPower() const;
    virtual void setTransmissionPower(double transmissionPower);
    virtual int getModulationOrder() const;
    virtual void setModulationOrder(int modulationOrder);
    virtual double getDutyCycle() const;
    virtual void setDutyCycle(double dutyCycle);
};

inline void doPacking(cCommBuffer *b, VLCBeaconMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VLCBeaconMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/VLCpacket.msg:88</tt> by nedtool.
 * <pre>
 * packet dataPacket extends VLCpacket
 * {
 *     int modulationType @enum(VLCmodulationType);
 *     double transmissionPower;
 *     int modulationOrder;
 *     double dutyCycle;
 *     string content;
 *     double transmissionStartTime;
 *     int sourceAddress;
 *     int destinationAddress;
 * }
 * </pre>
 */
class dataPacket : public ::VLCpacket
{
  protected:
    int modulationType_var;
    double transmissionPower_var;
    int modulationOrder_var;
    double dutyCycle_var;
    opp_string content_var;
    double transmissionStartTime_var;
    int sourceAddress_var;
    int destinationAddress_var;

  private:
    void copy(const dataPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const dataPacket&);

  public:
    dataPacket(const char *name=NULL, int kind=0);
    dataPacket(const dataPacket& other);
    virtual ~dataPacket();
    dataPacket& operator=(const dataPacket& other);
    virtual dataPacket *dup() const {return new dataPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getModulationType() const;
    virtual void setModulationType(int modulationType);
    virtual double getTransmissionPower() const;
    virtual void setTransmissionPower(double transmissionPower);
    virtual int getModulationOrder() const;
    virtual void setModulationOrder(int modulationOrder);
    virtual double getDutyCycle() const;
    virtual void setDutyCycle(double dutyCycle);
    virtual const char * getContent() const;
    virtual void setContent(const char * content);
    virtual double getTransmissionStartTime() const;
    virtual void setTransmissionStartTime(double transmissionStartTime);
    virtual int getSourceAddress() const;
    virtual void setSourceAddress(int sourceAddress);
    virtual int getDestinationAddress() const;
    virtual void setDestinationAddress(int destinationAddress);
};

inline void doPacking(cCommBuffer *b, dataPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, dataPacket& obj) {obj.parsimUnpack(b);}


#endif // ifndef _VLCPACKET_M_H_

